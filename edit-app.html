<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lumina Studio Pro | Enterprise Vector Editor</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Font Awesome -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />

    <!-- Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --accent: #3b82f6;
        --bg-dark: #09090b;
        --panel-bg: #18181b;
        --border: #27272a;
      }
      body {
        font-family: "Inter", sans-serif;
        background-color: var(--bg-dark);
        overflow: hidden;
        color: #e4e4e7;
      }

      /* UI Polish */
      .glass-panel {
        background: rgba(24, 24, 27, 0.95);
        backdrop-filter: blur(8px);
        border-right: 1px solid var(--border);
      }
      .tool-btn {
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .tool-btn.active {
        background: rgba(59, 130, 246, 0.15);
        color: #60a5fa;
        border-left: 3px solid #60a5fa;
      }
      .tool-btn:not(.active):hover {
        background: rgba(255, 255, 255, 0.05);
        color: white;
      }

      /* Inputs */
      .input-group label {
        font-size: 0.65rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: #71717a;
        font-weight: 600;
        margin-bottom: 2px;
        display: block;
      }
      .dark-input {
        background: #09090b;
        border: 1px solid #27272a;
        color: #e4e4e7;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 0.75rem;
        width: 100%;
        font-family: "JetBrains Mono", monospace;
        transition: border-color 0.15s;
      }
      .dark-input:focus {
        outline: none;
        border-color: #3b82f6;
      }

      /* Canvas */
      #canvas-wrapper {
        cursor: default;
      }
      #canvas-wrapper.panning {
        cursor: grab;
      }
      #canvas-wrapper.panning:active {
        cursor: grabbing;
      }

      /* Scrollbars */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: #3f3f46;
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #52525b;
      }

      /* Custom Range Slider */
      input[type="range"] {
        -webkit-appearance: none;
        background: transparent;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 12px;
        width: 12px;
        border-radius: 50%;
        background: #60a5fa;
        margin-top: -5px;
        cursor: pointer;
      }
      input[type="range"]::-webkit-slider-runnable-track {
        width: 100%;
        height: 2px;
        background: #3f3f46;
      }
    </style>

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              gray: { 750: "#2d3748", 850: "#1a202c", 950: "#09090b" },
            },
          },
        },
      };
    </script>
  </head>
  <body class="flex flex-col h-screen select-none text-sm">
    <!-- App Header -->
    <header
      class="h-10 bg-zinc-900 border-b border-zinc-800 flex items-center justify-between px-3 shrink-0 z-50"
    >
      <div class="flex items-center gap-3">
        <div class="flex items-center gap-2">
          <div
            class="w-5 h-5 bg-blue-600 rounded flex items-center justify-center text-[10px] font-bold"
          >
            L
          </div>
          <span class="font-semibold text-gray-200 tracking-tight"
            >Lumina <span class="text-blue-500">Pro</span></span
          >
        </div>

        <div class="h-4 w-px bg-zinc-700 mx-2"></div>

        <!-- Menu -->
        <div class="flex items-center gap-1">
          <button
            onclick="app.actions.newFile()"
            class="px-2 py-1 hover:bg-zinc-800 rounded text-gray-400 hover:text-gray-100 transition"
          >
            File
          </button>
          <button
            onclick="app.actions.exportJSON()"
            class="px-2 py-1 hover:bg-zinc-800 rounded text-gray-400 hover:text-gray-100 transition"
          >
            Save
          </button>
          <div class="relative group">
            <button
              class="px-2 py-1 hover:bg-zinc-800 rounded text-gray-400 hover:text-gray-100 transition"
            >
              Export
            </button>
            <div
              class="absolute top-full left-0 mt-1 w-32 bg-zinc-800 border border-zinc-700 rounded shadow-xl hidden group-hover:block p-1"
            >
              <button
                onclick="app.actions.exportPNG()"
                class="w-full text-left px-2 py-1.5 hover:bg-zinc-700 rounded text-xs text-gray-300"
              >
                PNG Image
              </button>
              <button
                onclick="app.actions.exportJSON()"
                class="w-full text-left px-2 py-1.5 hover:bg-zinc-700 rounded text-xs text-gray-300"
              >
                Project JSON
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="flex items-center gap-4">
        <div
          class="flex items-center gap-2 text-xs text-zinc-500 bg-zinc-950 px-2 py-1 rounded border border-zinc-800"
        >
          <span id="zoom-display">100%</span>
          <div class="h-3 w-px bg-zinc-800"></div>
          <span id="coord-display">X: 0 Y: 0</span>
        </div>
        <button
          class="bg-blue-600 hover:bg-blue-500 text-white px-3 py-1 rounded text-xs font-semibold shadow-lg shadow-blue-500/20 transition"
        >
          Share
        </button>
      </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
      <!-- Toolbar (Left) -->
      <aside
        class="w-12 glass-panel flex flex-col items-center py-3 gap-2 shrink-0 z-40"
      >
        <button
          onclick="app.setTool('select')"
          id="tool-select"
          class="tool-btn active w-8 h-8 rounded flex items-center justify-center text-gray-400"
          title="Move (V)"
        >
          <i class="fas fa-mouse-pointer text-xs"></i>
        </button>
        <button
          onclick="app.setTool('rect')"
          id="tool-rect"
          class="tool-btn w-8 h-8 rounded flex items-center justify-center text-gray-400"
          title="Rectangle (R)"
        >
          <i class="far fa-square text-xs"></i>
        </button>
        <button
          onclick="app.setTool('circle')"
          id="tool-circle"
          class="tool-btn w-8 h-8 rounded flex items-center justify-center text-gray-400"
          title="Circle (C)"
        >
          <i class="far fa-circle text-xs"></i>
        </button>
        <button
          onclick="app.setTool('pen')"
          id="tool-pen"
          class="tool-btn w-8 h-8 rounded flex items-center justify-center text-gray-400"
          title="Pen Tool (P)"
        >
          <i class="fas fa-pen-nib text-xs"></i>
        </button>
        <button
          onclick="app.setTool('text')"
          id="tool-text"
          class="tool-btn w-8 h-8 rounded flex items-center justify-center text-gray-400"
          title="Text (T)"
        >
          <i class="fas fa-font text-xs"></i>
        </button>

        <div class="h-px w-6 bg-zinc-800 my-1"></div>

        <label
          class="w-8 h-8 rounded hover:bg-zinc-800 flex items-center justify-center text-gray-400 cursor-pointer"
          title="Upload Image"
        >
          <i class="far fa-image text-xs"></i>
          <input
            type="file"
            id="image-upload"
            accept="image/*"
            class="hidden"
            onchange="app.actions.handleImageUpload(event)"
          />
        </label>

        <div class="mt-auto flex flex-col gap-2">
          <button
            onclick="app.history.undo()"
            class="w-8 h-8 rounded hover:bg-zinc-800 flex items-center justify-center text-gray-500 hover:text-white transition"
          >
            <i class="fas fa-undo text-xs"></i>
          </button>
          <button
            onclick="app.history.redo()"
            class="w-8 h-8 rounded hover:bg-zinc-800 flex items-center justify-center text-gray-500 hover:text-white transition"
          >
            <i class="fas fa-redo text-xs"></i>
          </button>
        </div>
      </aside>

      <!-- Main Workspace -->
      <main
        id="canvas-wrapper"
        class="flex-1 relative bg-[#0e0e11] overflow-hidden"
      >
        <!-- Rulers (Visual Only for now) -->
        <div
          class="absolute top-0 left-0 w-full h-6 bg-zinc-900 border-b border-zinc-800 z-10 flex text-[10px] text-zinc-600 items-end px-2 select-none pointer-events-none"
        >
          <span class="ml-10">0</span><span class="ml-20">100</span
          ><span class="ml-20">200</span><span class="ml-20">300</span
          ><span class="ml-20">400</span><span class="ml-20">500</span
          ><span class="ml-20">600</span>
        </div>
        <div
          class="absolute top-6 left-0 w-6 h-full bg-zinc-900 border-r border-zinc-800 z-10 flex flex-col text-[10px] text-zinc-600 items-center pt-2 select-none pointer-events-none"
        >
          <span class="mt-10 rotate-90">100</span
          ><span class="mt-20 rotate-90">200</span
          ><span class="mt-20 rotate-90">300</span>
        </div>

        <!-- Canvas -->
        <canvas id="main-canvas" class="block outline-none touch-none"></canvas>

        <!-- Context Menu (Hidden by default) -->
        <div
          id="context-menu"
          class="absolute hidden bg-zinc-800 border border-zinc-700 rounded shadow-xl py-1 z-50 min-w-[140px]"
        >
          <button
            onclick="app.actions.bringToFront()"
            class="w-full text-left px-3 py-1.5 text-xs text-gray-300 hover:bg-zinc-700 hover:text-white flex items-center gap-2"
          >
            <i class="fas fa-arrow-up w-3"></i> Bring to Front
          </button>
          <button
            onclick="app.actions.sendToBack()"
            class="w-full text-left px-3 py-1.5 text-xs text-gray-300 hover:bg-zinc-700 hover:text-white flex items-center gap-2"
          >
            <i class="fas fa-arrow-down w-3"></i> Send to Back
          </button>
          <div class="h-px bg-zinc-700 my-1"></div>
          <button
            onclick="app.actions.duplicate()"
            class="w-full text-left px-3 py-1.5 text-xs text-gray-300 hover:bg-zinc-700 hover:text-white flex items-center gap-2"
          >
            <i class="far fa-copy w-3"></i> Duplicate
          </button>
          <button
            onclick="app.actions.deleteSelected()"
            class="w-full text-left px-3 py-1.5 text-xs text-red-400 hover:bg-red-900/30 hover:text-red-300 flex items-center gap-2"
          >
            <i class="fas fa-trash w-3"></i> Delete
          </button>
        </div>
      </main>

      <!-- Right Sidebar (Properties) -->
      <aside
        class="w-64 bg-zinc-900 border-l border-zinc-800 flex flex-col shrink-0 z-40"
      >
        <!-- Tabs -->
        <div class="flex border-b border-zinc-800">
          <button
            onclick="app.ui.switchTab('design')"
            id="tab-design"
            class="flex-1 py-2 text-xs font-medium text-blue-400 border-b-2 border-blue-500 bg-zinc-800/50"
          >
            Design
          </button>
          <button
            onclick="app.ui.switchTab('layers')"
            id="tab-layers"
            class="flex-1 py-2 text-xs font-medium text-zinc-500 hover:text-zinc-300 border-b-2 border-transparent"
          >
            Layers
          </button>
        </div>

        <div id="panel-design" class="flex-1 overflow-y-auto p-4 space-y-6">
          <!-- Alignment (Visual Only) -->
          <div class="flex justify-between px-1">
            <button class="text-zinc-500 hover:text-white">
              <i class="fas fa-align-left"></i>
            </button>
            <button class="text-zinc-500 hover:text-white">
              <i class="fas fa-align-center"></i>
            </button>
            <button class="text-zinc-500 hover:text-white">
              <i class="fas fa-align-right"></i>
            </button>
            <button class="text-zinc-500 hover:text-white">
              <i class="fas fa-align-justify"></i>
            </button>
          </div>

          <!-- Transform -->
          <div>
            <h3
              class="text-[10px] font-bold text-zinc-500 uppercase tracking-wider mb-2"
            >
              Transform
            </h3>
            <div class="grid grid-cols-2 gap-2 mb-2">
              <div class="input-group">
                <label>X</label>
                <input
                  type="number"
                  id="prop-x"
                  class="dark-input"
                  onchange="app.props.updateTransform()"
                />
              </div>
              <div class="input-group">
                <label>Y</label>
                <input
                  type="number"
                  id="prop-y"
                  class="dark-input"
                  onchange="app.props.updateTransform()"
                />
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2 mb-2">
              <div class="input-group">
                <label>W</label>
                <input
                  type="number"
                  id="prop-w"
                  class="dark-input"
                  onchange="app.props.updateTransform()"
                />
              </div>
              <div class="input-group">
                <label>H</label>
                <input
                  type="number"
                  id="prop-h"
                  class="dark-input"
                  onchange="app.props.updateTransform()"
                />
              </div>
            </div>
            <div class="input-group">
              <label>Rotation (Â°)</label>
              <input
                type="number"
                id="prop-rotation"
                class="dark-input"
                onchange="app.props.updateTransform()"
              />
            </div>
          </div>

          <div class="h-px bg-zinc-800"></div>

          <!-- Appearance -->
          <div>
            <h3
              class="text-[10px] font-bold text-zinc-500 uppercase tracking-wider mb-2"
            >
              Appearance
            </h3>

            <div class="mb-3">
              <div class="flex justify-between items-center mb-1">
                <label class="text-[10px] text-zinc-400">Fill</label>
                <input
                  type="color"
                  id="prop-fill-color"
                  class="w-4 h-4 rounded border-none bg-transparent p-0 cursor-pointer"
                  onchange="app.props.updateStyle()"
                />
              </div>
              <div class="flex items-center gap-2">
                <input
                  type="text"
                  id="prop-fill-hex"
                  class="dark-input uppercase"
                  placeholder="#000000"
                  onchange="app.props.updateStyleHex()"
                />
                <span class="text-zinc-600 text-xs">100%</span>
              </div>
            </div>

            <div class="mb-3">
              <div class="flex justify-between items-center mb-1">
                <label class="text-[10px] text-zinc-400">Stroke</label>
                <input
                  type="color"
                  id="prop-stroke-color"
                  class="w-4 h-4 rounded border-none bg-transparent p-0 cursor-pointer"
                  onchange="app.props.updateStyle()"
                />
              </div>
              <div class="flex items-center gap-2">
                <input
                  type="text"
                  id="prop-stroke-hex"
                  class="dark-input uppercase"
                  placeholder="#000000"
                  onchange="app.props.updateStyleHex()"
                />
                <input
                  type="number"
                  id="prop-stroke-width"
                  class="dark-input w-16"
                  value="1"
                  min="0"
                  onchange="app.props.updateStyle()"
                />
              </div>
            </div>

            <div class="mb-3">
              <label class="text-[10px] text-zinc-400 mb-1 block"
                >Opacity</label
              >
              <input
                type="range"
                id="prop-opacity"
                min="0"
                max="1"
                step="0.01"
                oninput="app.props.updateStyle()"
                class="w-full"
              />
            </div>

            <div class="mb-3">
              <div class="flex items-center gap-2 mb-1">
                <input
                  type="checkbox"
                  id="prop-shadow"
                  class="rounded bg-zinc-800 border-zinc-700 text-blue-500 focus:ring-0"
                  onchange="app.props.updateStyle()"
                />
                <label for="prop-shadow" class="text-[10px] text-zinc-400"
                  >Drop Shadow</label
                >
              </div>
            </div>
          </div>

          <div class="h-px bg-zinc-800"></div>

          <!-- Action Buttons -->
          <div class="grid grid-cols-2 gap-2">
            <button
              onclick="app.actions.groupSelected()"
              class="bg-zinc-800 hover:bg-zinc-700 text-zinc-300 py-1.5 rounded text-xs transition"
            >
              Group
            </button>
            <button
              onclick="app.actions.ungroupSelected()"
              class="bg-zinc-800 hover:bg-zinc-700 text-zinc-300 py-1.5 rounded text-xs transition"
            >
              Ungroup
            </button>
          </div>
        </div>

        <div id="panel-layers" class="hidden flex-1 overflow-y-auto p-2">
          <div id="layer-list" class="space-y-0.5">
            <!-- Layer Items Injected Here -->
          </div>
        </div>
      </aside>
    </div>

    <!-- Text Input Overlay -->
    <div
      id="text-editor"
      class="absolute hidden z-50 transform -translate-x-1/2 -translate-y-1/2"
    >
      <textarea
        id="text-edit-area"
        class="bg-transparent text-white p-0 border-2 border-blue-500 outline-none resize-none overflow-hidden text-center"
        style="font-family: 'Inter', sans-serif;"
      ></textarea>
    </div>

    <script>
      /**
       * Lumina Studio Pro v2.0 - Core Engine
       * Implements Scene Graph, Matrix Transformations, and Event Handling
       */

      const UTILS = {
        uid: () =>
          Date.now().toString(36) + Math.random().toString(36).substr(2),
        radToDeg: (r) => r * (180 / Math.PI),
        degToRad: (d) => d * (Math.PI / 180),
        getDistance: (p1, p2) =>
          Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)),
        rotatePoint: (px, py, cx, cy, angle) => {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          return {
            x: cos * (px - cx) - sin * (py - cy) + cx,
            y: sin * (px - cx) + cos * (py - cy) + cy,
          };
        },
        isPointInPoly: (point, vs) => {
          let x = point.x,
            y = point.y;
          let inside = false;
          for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            let xi = vs[i].x,
              yi = vs[i].y;
            let xj = vs[j].x,
              yj = vs[j].y;
            let intersect =
              yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
            if (intersect) inside = !inside;
          }
          return inside;
        },
      };

      // --- Model Classes ---

      class Shape {
        constructor(type, x, y, style = {}) {
          this.id = UTILS.uid();
          this.type = type;
          this.x = x;
          this.y = y;
          this.width = 100;
          this.height = 100;
          this.rotation = 0; // Radians
          this.fill = style.fill || "#3b82f6";
          this.stroke = style.stroke || "#000000";
          this.strokeWidth = style.strokeWidth || 0;
          this.opacity = style.opacity !== undefined ? style.opacity : 1;
          this.shadow = style.shadow || false;
          this.points = []; // For polygons/lines
          this.image = null; // For image type
          this.text = "Double click to edit"; // For text type
          this.fontSize = 24;
          this.visible = true;
          this.locked = false;
          this.name = type.charAt(0).toUpperCase() + type.slice(1);
        }

        // Get bounding box considering rotation for hit testing is complex
        // We use simple AABB for this demo, but the transformer handles rotation
        getBounds() {
          return { x: this.x, y: this.y, w: this.width, h: this.height };
        }

        draw(ctx) {
          if (!this.visible) return;
          ctx.save();
          ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
          ctx.rotate(this.rotation);
          ctx.translate(
            -(this.x + this.width / 2),
            -(this.y + this.height / 2)
          );
          ctx.globalAlpha = this.opacity;

          if (this.shadow) {
            ctx.shadowColor = "rgba(0,0,0,0.5)";
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;
          }

          ctx.beginPath();
          ctx.strokeStyle = this.stroke;
          ctx.lineWidth = this.strokeWidth;
          ctx.fillStyle = this.fill;

          if (this.type === "rect") {
            ctx.rect(this.x, this.y, this.width, this.height);
            ctx.fill();
            if (this.strokeWidth > 0) ctx.stroke();
          } else if (this.type === "circle") {
            ctx.ellipse(
              this.x + this.width / 2,
              this.y + this.height / 2,
              this.width / 2,
              this.height / 2,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();
            if (this.strokeWidth > 0) ctx.stroke();
          } else if (this.type === "image" && this.image) {
            try {
              ctx.drawImage(
                this.image,
                this.x,
                this.y,
                this.width,
                this.height
              );
              if (this.strokeWidth > 0) {
                ctx.strokeRect(this.x, this.y, this.width, this.height);
              }
            } catch (e) {}
          } else if (this.type === "text") {
            ctx.font = `${this.fontSize}px Inter, sans-serif`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(
              this.text,
              this.x + this.width / 2,
              this.y + this.height / 2
            );
            // Update dims based on text measurement logic would go here
          } else if (this.type === "poly") {
            if (this.points.length > 0) {
              ctx.moveTo(this.points[0].x, this.points[0].y);
              for (let i = 1; i < this.points.length; i++)
                ctx.lineTo(this.points[i].x, this.points[i].y);
              if (this.points.length > 2) ctx.closePath();
              ctx.fill();
              if (this.strokeWidth > 0) ctx.stroke();
            }
          }

          ctx.restore();
        }

        // Checks if point (in global space) is inside this shape
        hitTest(mx, my) {
          // Simplified hit test: reverse rotate the mouse point around shape center
          const cx = this.x + this.width / 2;
          const cy = this.y + this.height / 2;
          const rp = UTILS.rotatePoint(mx, my, cx, cy, -this.rotation);

          if (
            this.type === "rect" ||
            this.type === "image" ||
            this.type === "text"
          ) {
            return (
              rp.x >= this.x &&
              rp.x <= this.x + this.width &&
              rp.y >= this.y &&
              rp.y <= this.y + this.height
            );
          }
          if (this.type === "circle") {
            const dx = rp.x - cx;
            const dy = rp.y - cy;
            // ellipse equation
            return (
              (dx * dx) / ((this.width / 2) * (this.width / 2)) +
                (dy * dy) / ((this.height / 2) * (this.height / 2)) <=
              1
            );
          }
          if (this.type === "poly") {
            // For poly, we'd need to inverse transform the points or the mouse.
            // Simplified: AABB check on the bounds
            return (
              rp.x >= this.x &&
              rp.x <= this.x + this.width &&
              rp.y >= this.y &&
              rp.y <= this.y + this.height
            );
          }
          return false;
        }
      }

      class HistoryManager {
        constructor() {
          this.stack = [];
          this.pointer = -1;
        }
        save(state) {
          // Remove redo history if we are in middle of stack
          if (this.pointer < this.stack.length - 1) {
            this.stack = this.stack.slice(0, this.pointer + 1);
          }
          // Deep copy
          const snapshot = JSON.stringify(state);
          // Limit stack
          if (this.stack.length > 20) this.stack.shift();

          this.stack.push(snapshot);
          this.pointer = this.stack.length - 1;
        }
        undo() {
          if (this.pointer > 0) {
            this.pointer--;
            return JSON.parse(this.stack[this.pointer]);
          }
          return null;
        }
        redo() {
          if (this.pointer < this.stack.length - 1) {
            this.pointer++;
            return JSON.parse(this.stack[this.pointer]);
          }
          return null;
        }
      }

      // --- Main Application ---

      class Application {
        constructor() {
          this.canvas = document.getElementById("main-canvas");
          this.ctx = this.canvas.getContext("2d");
          this.wrapper = document.getElementById("canvas-wrapper");

          // Viewport
          this.zoom = 1;
          this.panX = 0;
          this.panY = 0;

          // State
          this.shapes = [];
          this.selection = []; // Array of ids
          this.tool = "select"; // select, rect, circle, pen, text, hand
          this.isDragging = false;
          this.dragStart = { x: 0, y: 0 };
          this.transformHandle = null; // 'tl', 'tr', 'bl', 'br', 'rot', 'body'

          // Temp objects
          this.currentPoly = null;

          // History
          this.history = new HistoryManager();

          // Bindings
          this.setupEvents();
          this.resize();

          // Initial save
          this.history.save(this.shapes);

          // Loop
          requestAnimationFrame(() => this.loop());
        }

        setupEvents() {
          window.addEventListener("resize", () => this.resize());

          // Mouse
          this.canvas.addEventListener("mousedown", (e) => this.onMouseDown(e));
          window.addEventListener("mousemove", (e) => this.onMouseMove(e));
          window.addEventListener("mouseup", (e) => this.onMouseUp(e));
          this.canvas.addEventListener("wheel", (e) => this.onWheel(e), {
            passive: false,
          });

          // Keyboard
          window.addEventListener("keydown", (e) => this.onKeyDown(e));
          window.addEventListener("keyup", (e) => {
            if (e.key === " ") this.wrapper.classList.remove("panning");
          });

          // Context Menu
          this.canvas.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            const menu = document.getElementById("context-menu");
            menu.style.display = "block";
            menu.style.left = e.clientX + "px";
            menu.style.top = e.clientY + "px";
          });
          window.addEventListener(
            "click",
            () =>
              (document.getElementById("context-menu").style.display = "none")
          );
        }

        resize() {
          this.canvas.width = this.wrapper.clientWidth;
          this.canvas.height = this.wrapper.clientHeight;
          this.render();
        }

        // --- Coordinate Systems ---

        screenToWorld(sx, sy) {
          return {
            x: (sx - this.panX) / this.zoom,
            y: (sy - this.panY) / this.zoom,
          };
        }

        worldToScreen(wx, wy) {
          return {
            x: wx * this.zoom + this.panX,
            y: wy * this.zoom + this.panY,
          };
        }

        // --- Interactions ---

        onMouseDown(e) {
          if (e.button === 1 || (e.button === 0 && e.key === " ")) {
            // Middle click or Space+Left
            this.isDragging = true;
            this.tool = "hand";
            this.dragStart = { x: e.clientX, y: e.clientY };
            return;
          }

          const rect = this.canvas.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          const worldPos = this.screenToWorld(mx, my);

          if (this.tool === "select") {
            // Check handles first if selection exists
            const handle = this.checkHandles(mx, my);
            if (handle) {
              this.transformHandle = handle;
              this.isDragging = true;
              this.dragStart = worldPos;
              return;
            }

            // Hit test
            // Reverse iterate for top-most
            let hit = null;
            for (let i = this.shapes.length - 1; i >= 0; i--) {
              if (this.shapes[i].hitTest(worldPos.x, worldPos.y)) {
                hit = this.shapes[i];
                break;
              }
            }

            if (hit) {
              if (!e.shiftKey && !this.selection.includes(hit.id)) {
                this.selection = [hit.id];
              } else if (e.shiftKey && !this.selection.includes(hit.id)) {
                this.selection.push(hit.id);
              }
              this.isDragging = true;
              this.transformHandle = "body";
              this.dragStart = worldPos;
              this.refreshPropertiesPanel();
              this.updateLayersPanel();
            } else {
              // Clicked empty space
              this.selection = [];
              this.refreshPropertiesPanel();
              this.updateLayersPanel();
            }
          } else if (this.tool === "rect" || this.tool === "circle") {
            const s = new Shape(this.tool, worldPos.x, worldPos.y);
            s.width = 0;
            s.height = 0;
            this.shapes.push(s);
            this.selection = [s.id];
            this.isDragging = true;
            this.transformHandle = "creating";
          } else if (this.tool === "pen") {
            if (!this.currentPoly) {
              this.currentPoly = new Shape("poly", 0, 0); // x,y usually 0 for poly container
              this.currentPoly.points = [{ x: worldPos.x, y: worldPos.y }];
              this.shapes.push(this.currentPoly);
            } else {
              this.currentPoly.points.push({ x: worldPos.x, y: worldPos.y });
            }
          } else if (this.tool === "text") {
            const s = new Shape("text", worldPos.x, worldPos.y);
            s.width = 100;
            s.height = 30; // approx
            this.shapes.push(s);
            this.tool = "select"; // Switch back immediately
            this.selection = [s.id];
            this.editText(s);
            this.updateLayersPanel();
          }
        }

        onMouseMove(e) {
          const rect = this.canvas.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          const worldPos = this.screenToWorld(mx, my);

          // Update UI coords
          document.getElementById("coord-display").innerText = `X: ${Math.round(
            worldPos.x
          )} Y: ${Math.round(worldPos.y)}`;

          // Handle cursors
          if (
            this.tool === "select" &&
            !this.isDragging &&
            this.selection.length === 1
          ) {
            const handle = this.checkHandles(mx, my);
            this.canvas.style.cursor = handle
              ? handle === "rot"
                ? "alias"
                : "nwse-resize"
              : "default";
          }

          if (!this.isDragging) return;

          if (this.tool === "hand") {
            const dx = e.clientX - this.dragStart.x;
            const dy = e.clientY - this.dragStart.y;
            this.panX += dx;
            this.panY += dy;
            this.dragStart = { x: e.clientX, y: e.clientY };
            return;
          }

          if (this.transformHandle === "body") {
            const dx = worldPos.x - this.dragStart.x;
            const dy = worldPos.y - this.dragStart.y;

            this.selection.forEach((id) => {
              const s = this.getShape(id);
              s.x += dx;
              s.y += dy;
              // For poly, move points
              if (s.type === "poly") {
                s.points.forEach((p) => {
                  p.x += dx;
                  p.y += dy;
                });
              }
            });
            this.dragStart = worldPos;
            this.refreshPropertiesPanel();
          } else if (this.transformHandle === "creating") {
            const s = this.getShape(this.selection[0]);
            s.width = worldPos.x - s.x;
            s.height = worldPos.y - s.y;
          } else if (this.selection.length === 1) {
            // Resizing / Rotating
            const s = this.getShape(this.selection[0]);
            if (this.transformHandle === "br") {
              s.width = worldPos.x - s.x;
              s.height = worldPos.y - s.y;
            } else if (this.transformHandle === "rot") {
              // Calculate angle from center
              const cx = s.x + s.width / 2;
              const cy = s.y + s.height / 2;
              s.rotation =
                Math.atan2(worldPos.y - cy, worldPos.x - cx) + Math.PI / 2;
            }
            this.refreshPropertiesPanel();
          }
        }

        onMouseUp(e) {
          if (this.isDragging) {
            if (this.tool !== "hand") {
              this.history.save(this.shapes);
              this.updateLayersPanel();
            }
          }
          this.isDragging = false;
          if (this.tool === "rect" || this.tool === "circle") {
            this.setTool("select");
          }
        }

        onWheel(e) {
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            const delta = -e.deltaY * zoomSensitivity;
            const newZoom = Math.max(0.1, Math.min(5, this.zoom + delta));

            // Zoom towards mouse pointer logic usually goes here, simplified for now:
            this.zoom = newZoom;
            document.getElementById("zoom-display").innerText =
              Math.round(this.zoom * 100) + "%";
          } else {
            this.panX -= e.deltaX;
            this.panY -= e.deltaY;
          }
        }

        onKeyDown(e) {
          if (e.key === " " && !this.isDragging) {
            this.wrapper.classList.add("panning");
          }
          if (e.key === "v") this.setTool("select");
          if (e.key === "r") this.setTool("rect");
          if (e.key === "c") this.setTool("circle");
          if (e.key === "p") this.setTool("pen");
          if (e.key === "Delete" || e.key === "Backspace")
            this.actions.deleteSelected();

          // Finish Pen
          if (e.key === "Enter" && this.tool === "pen") {
            this.currentPoly = null;
            this.setTool("select");
          }

          // Undo/Redo
          if ((e.ctrlKey || e.metaKey) && e.key === "z") {
            e.preventDefault();
            const state = this.history.undo();
            if (state) this.restoreState(state);
          }
          if ((e.ctrlKey || e.metaKey) && e.key === "y") {
            e.preventDefault();
            const state = this.history.redo();
            if (state) this.restoreState(state);
          }
        }

        // --- Rendering ---

        render() {
          // Clear
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Grid Background
          this.ctx.save();
          this.ctx.translate(this.panX, this.panY);
          this.ctx.scale(this.zoom, this.zoom);

          // Draw shapes
          this.shapes.forEach((s) => s.draw(this.ctx));

          // Draw Selection Overlay
          this.drawOverlay();

          this.ctx.restore();
        }

        loop() {
          this.render();
          requestAnimationFrame(() => this.loop());
        }

        drawOverlay() {
          if (this.selection.length === 0) return;

          this.ctx.save();
          this.ctx.strokeStyle = "#3b82f6";
          this.ctx.lineWidth = 1 / this.zoom;

          // For single selection, show detailed handles
          if (this.selection.length === 1) {
            const s = this.getShape(this.selection[0]);

            this.ctx.translate(s.x + s.width / 2, s.y + s.height / 2);
            this.ctx.rotate(s.rotation);
            this.ctx.translate(-(s.x + s.width / 2), -(s.y + s.height / 2));

            // Bounds
            this.ctx.strokeRect(s.x, s.y, s.width, s.height);

            // Handles
            const hSize = 8 / this.zoom;
            this.ctx.fillStyle = "#fff";

            // BR Handle
            this.ctx.fillRect(
              s.x + s.width - hSize / 2,
              s.y + s.height - hSize / 2,
              hSize,
              hSize
            );
            this.ctx.strokeRect(
              s.x + s.width - hSize / 2,
              s.y + s.height - hSize / 2,
              hSize,
              hSize
            );

            // Rotation Handle (Top Center sticks out)
            this.ctx.beginPath();
            this.ctx.moveTo(s.x + s.width / 2, s.y);
            this.ctx.lineTo(s.x + s.width / 2, s.y - 20 / this.zoom);
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.arc(
              s.x + s.width / 2,
              s.y - 20 / this.zoom,
              hSize / 2,
              0,
              Math.PI * 2
            );
            this.ctx.fill();
            this.ctx.stroke();
          } else {
            // Multi-selection (simple box around all)
            // Calculation is complex for rotation, skipping for brevity
          }
          this.ctx.restore();
        }

        checkHandles(mx, my) {
          if (this.selection.length !== 1) return null;
          const s = this.getShape(this.selection[0]);
          const wp = this.screenToWorld(mx, my);

          // Transform mouse point into shape local space
          const cx = s.x + s.width / 2;
          const cy = s.y + s.height / 2;
          const lp = UTILS.rotatePoint(wp.x, wp.y, cx, cy, -s.rotation);

          const threshold = 10 / this.zoom;

          // Check BR Handle
          if (
            Math.abs(lp.x - (s.x + s.width)) < threshold &&
            Math.abs(lp.y - (s.y + s.height)) < threshold
          ) {
            return "br";
          }

          // Check Rot Handle
          if (
            Math.abs(lp.x - (s.x + s.width / 2)) < threshold &&
            Math.abs(lp.y - (s.y - 20 / this.zoom)) < threshold
          ) {
            return "rot";
          }

          return null;
        }

        // --- Logic Helpers ---

        setTool(t) {
          this.tool = t;
          // UI updates
          document
            .querySelectorAll(".tool-btn")
            .forEach((b) => b.classList.remove("active"));
          const btn = document.getElementById(`tool-${t}`);
          if (btn) btn.classList.add("active");
        }

        getShape(id) {
          return this.shapes.find((s) => s.id === id);
        }

        restoreState(shapeData) {
          // Re-instantiate classes from JSON data
          this.shapes = shapeData.map((d) => {
            const s = new Shape(d.type, d.x, d.y);
            Object.assign(s, d);
            // Image element reference is lost in JSON, need to handle re-load in real app
            // Text is preserved
            return s;
          });
          this.selection = [];
          this.render();
          this.updateLayersPanel();
        }

        // --- UI Panels ---

        updateLayersPanel() {
          const list = document.getElementById("layer-list");
          list.innerHTML = "";
          [...this.shapes].reverse().forEach((s) => {
            const div = document.createElement("div");
            div.className = `flex items-center gap-2 p-1.5 rounded cursor-pointer text-xs ${
              this.selection.includes(s.id)
                ? "bg-blue-900/30 text-blue-200"
                : "hover:bg-zinc-800 text-gray-400"
            }`;
            div.innerHTML = `
                        <i class="fas ${
                          s.visible ? "fa-eye" : "fa-eye-slash"
                        } w-4 text-center hover:text-white" onclick="app.actions.toggleVis('${
              s.id
            }')"></i>
                        <span class="flex-1 truncate">${s.name}</span>
                        ${
                          s.locked
                            ? '<i class="fas fa-lock text-[10px]"></i>'
                            : ""
                        }
                    `;
            div.onclick = (e) => {
              if (
                !e.target.classList.contains("fa-eye") &&
                !e.target.classList.contains("fa-eye-slash")
              ) {
                this.selection = [s.id];
                this.refreshPropertiesPanel();
                this.updateLayersPanel(); // Recursive but fine for small counts
              }
            };
            list.appendChild(div);
          });
        }

        refreshPropertiesPanel() {
          if (this.selection.length === 1) {
            const s = this.getShape(this.selection[0]);
            document.getElementById("prop-x").value = Math.round(s.x);
            document.getElementById("prop-y").value = Math.round(s.y);
            document.getElementById("prop-w").value = Math.round(s.width);
            document.getElementById("prop-h").value = Math.round(s.height);
            document.getElementById("prop-rotation").value = Math.round(
              UTILS.radToDeg(s.rotation)
            );
            document.getElementById("prop-fill-hex").value = s.fill;
            document.getElementById(
              "prop-fill-color"
            ).value = s.fill.startsWith("#") ? s.fill : "#000000";
            document.getElementById("prop-opacity").value = s.opacity;
            document.getElementById("prop-stroke-width").value = s.strokeWidth;
            document.getElementById("prop-shadow").checked = s.shadow;
          }
        }

        editText(shape) {
          const editor = document.getElementById("text-editor");
          const area = document.getElementById("text-edit-area");

          // Position editor over shape
          const screenPos = this.worldToScreen(
            shape.x + shape.width / 2,
            shape.y + shape.height / 2
          );
          editor.style.left = screenPos.x + "px";
          editor.style.top = screenPos.y + "px";
          editor.style.display = "block";

          area.value = shape.text;
          area.style.fontSize = shape.fontSize * this.zoom + "px";
          area.focus();

          const saveText = () => {
            shape.text = area.value;
            editor.style.display = "none";
            this.history.save(this.shapes);
          };

          area.onblur = saveText;
          area.onkeydown = (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              area.blur();
            }
          };
        }
      }

      // --- Action Controllers ---

      const Actions = {
        deleteSelected: () => {
          app.shapes = app.shapes.filter((s) => !app.selection.includes(s.id));
          app.selection = [];
          app.history.save(app.shapes);
          app.updateLayersPanel();
        },
        bringToFront: () => {
          if (app.selection.length !== 1) return;
          const idx = app.shapes.findIndex((s) => s.id === app.selection[0]);
          if (idx < app.shapes.length - 1) {
            const s = app.shapes.splice(idx, 1)[0];
            app.shapes.push(s);
            app.updateLayersPanel();
          }
        },
        sendToBack: () => {
          if (app.selection.length !== 1) return;
          const idx = app.shapes.findIndex((s) => s.id === app.selection[0]);
          if (idx > 0) {
            const s = app.shapes.splice(idx, 1)[0];
            app.shapes.unshift(s);
            app.updateLayersPanel();
          }
        },
        handleImageUpload: (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              const s = new Shape("image", app.panX + 100, app.panY + 100);
              s.width = img.width / 2; // Scale down a bit initially
              s.height = img.height / 2;
              s.image = img;
              app.shapes.push(s);
              app.history.save(app.shapes);
              app.updateLayersPanel();
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
        },
        toggleVis: (id) => {
          const s = app.getShape(id);
          if (s) s.visible = !s.visible;
          app.updateLayersPanel();
        },
        exportPNG: () => {
          const link = document.createElement("a");
          link.download = "lumina-export.png";
          link.href = app.canvas.toDataURL();
          link.click();
        },
        exportJSON: () => {
          const data = JSON.stringify(app.shapes);
          const blob = new Blob([data], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.download = "lumina-project.json";
          link.href = url;
          link.click();
        },
        newFile: () => {
          if (confirm("Create new file? Unsaved changes will be lost.")) {
            app.shapes = [];
            app.selection = [];
            app.updateLayersPanel();
          }
        },
      };

      const PropsController = {
        updateTransform: () => {
          if (app.selection.length !== 1) return;
          const s = app.getShape(app.selection[0]);
          s.x = parseFloat(document.getElementById("prop-x").value) || 0;
          s.y = parseFloat(document.getElementById("prop-y").value) || 0;
          s.width = parseFloat(document.getElementById("prop-w").value) || 10;
          s.height = parseFloat(document.getElementById("prop-h").value) || 10;
          s.rotation = UTILS.degToRad(
            parseFloat(document.getElementById("prop-rotation").value) || 0
          );
          app.history.save(app.shapes);
        },
        updateStyle: () => {
          if (app.selection.length !== 1) return;
          const s = app.getShape(app.selection[0]);
          s.fill = document.getElementById("prop-fill-color").value;
          document.getElementById("prop-fill-hex").value = s.fill;

          s.stroke = document.getElementById("prop-stroke-color").value;
          document.getElementById("prop-stroke-hex").value = s.stroke;

          s.strokeWidth = parseFloat(
            document.getElementById("prop-stroke-width").value
          );
          s.opacity = parseFloat(document.getElementById("prop-opacity").value);
          s.shadow = document.getElementById("prop-shadow").checked;
          app.history.save(app.shapes);
        },
        updateStyleHex: () => {
          if (app.selection.length !== 1) return;
          const s = app.getShape(app.selection[0]);
          s.fill = document.getElementById("prop-fill-hex").value;
          s.stroke = document.getElementById("prop-stroke-hex").value;
          document.getElementById("prop-fill-color").value = s.fill.substring(
            0,
            7
          ); // basic hex
          app.history.save(app.shapes);
        },
      };

      const UIController = {
        switchTab: (tab) => {
          document.getElementById("tab-design").className =
            tab === "design"
              ? "flex-1 py-2 text-xs font-medium text-blue-400 border-b-2 border-blue-500 bg-zinc-800/50"
              : "flex-1 py-2 text-xs font-medium text-zinc-500 hover:text-zinc-300 border-b-2 border-transparent";
          document.getElementById("tab-layers").className =
            tab === "layers"
              ? "flex-1 py-2 text-xs font-medium text-blue-400 border-b-2 border-blue-500 bg-zinc-800/50"
              : "flex-1 py-2 text-xs font-medium text-zinc-500 hover:text-zinc-300 border-b-2 border-transparent";

          document.getElementById("panel-design").style.display =
            tab === "design" ? "block" : "none";
          document.getElementById("panel-layers").style.display =
            tab === "layers" ? "block" : "none";
        },
      };

      // --- Bootstrap ---
      const app = new Application();
      app.actions = Actions;
      app.props = PropsController;
      app.ui = UIController;
    </script>
  </body>
</html>
